name: Deploy to PRODUCTION EKS

on:
    pull_request:
      branches:
      - prod

env:
  ECR_REPOSITORY: repo-prod
  EKS_CLUSTER_NAME: eks-cluster-123 
  AWS_REGION: us-west-2

jobs:
  
  build:
    name: Deployment
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
    - name: Check out code
      uses: actions/checkout@v2
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{env.AWS_REGION}}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1  
    - name: Set up Git
      run: |
        git config --global user.name 'GitHub Actions'
        git config --global user.email 'github:actions@github.com'

    - name: Read Current Version from GitHub tags
      id: read-version
      run: |
        # Fetch all tags
        git fetch --depth=1 origin +refs/tags/*:refs/tags/*
      
        # Get the latest tag from GitHub repository
        LATEST_TAG=$(git describe --tags $(git rev-list --tags --max-count=1))
        echo "::set-output name=version::${LATEST_TAG}"
        echo "Current version-1: ${LATEST_TAG}"
    
    - name: Determine semantic version
      id: determine-version
      run: |
        # Extract commit message from the latest commit
        COMMIT_MESSAGE=$(git log -1 --pretty=%B)
    
        # Determine the version type based on the commit message
        if echo "$COMMIT_MESSAGE" | grep -q 'BREAKING CHANGE'; then
          echo "::set-output name=version::major"
        elif echo "$COMMIT_MESSAGE" | grep -q 'FEAT'; then
          echo "::set-output name=version::minor"
        else
          echo "::set-output name=version::patch"
        fi
    - name: Determine version update
      id: determine-update
      run: |
        VERSION=$(echo ${{ steps.determine-version.outputs.version }})
        if [ "$VERSION" = "major" ]; then
          echo "::set-output name=update::major"
        elif [ "$VERSION" = "minor" ]; then
          echo "::set-output name=update::minor"
        else
          echo "::set-output name=update::patch"
        fi  

    - name: Update Version
      id: update-version
      run: |
        CURRENT_VERSION=$(echo ${{ steps.read-version.outputs.version }})
        VERSION_TYPE=$(echo ${{ steps.determine-version.outputs.version }})
      
        # Parse the version numbers
        IFS='.' read -r -a VERSION_ARRAY <<< "${CURRENT_VERSION#v}" # Remove 'v' from the beginning
        MAJOR=${VERSION_ARRAY[0]}
        MINOR=${VERSION_ARRAY[1]}
        PATCH=${VERSION_ARRAY[2]}
      
        # Update version numbers based on the release type
        if [ "$VERSION_TYPE" = "major" ]; then
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
        elif [ "$VERSION_TYPE" = "minor" ]; then
          MINOR=$((MINOR + 1))
          PATCH=0
        else
          PATCH=$((PATCH + 1))
        fi
      
        # Generate the new version
        NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}" # Add 'v' to the beginning
        echo "$NEW_VERSION" > VERSION
        echo "::set-output name=new_version::$NEW_VERSION"
      
        echo "New version-2: $NEW_VERSION"

    - name: Tag and Push New Version
      run: |
          NEW_TAG=$(cat VERSION)
          git tag $NEW_TAG
          git push origin $NEW_TAG
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        IMAGE_TAG=$(cat VERSION)
        echo "the new tag is : $IMAGE_TAG"

        echo "ECR_REGISTRY: $ECR_REGISTRY"
        echo "ECR_REPOSITORY: $ECR_REPOSITORY"
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f Application/Dockerfile .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
  
    - name: Install Pritunl VPN
      run: |
        sudo tee /etc/apt/sources.list.d/pritunl.list << EOF
        deb https://repo.pritunl.com/stable/apt jammy main
        EOF
  
        sudo apt --assume-yes install gnupg
        gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys 7568D9BB55FF9E5287D586017AE645C0CF8E292A
        gpg --armor --export 7568D9BB55FF9E5287D586017AE645C0CF8E292A | sudo tee /etc/apt/trusted.gpg.d/pritunl.asc
        sudo apt update
        sudo apt install pritunl-client-electron

    - name: Connect VPN
      run: |
        pritunl-client add ./user-15.tar
        pritunl-client start "$(pritunl-client list | awk 'NR>2 {print $2}' | tr -d '[:space:]')" --password ${{ secrets.PRITUNL_PIN }} 
      
    - name: Update kube config
      run: |
       aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION
      
    - name: Set environment variable
      env:
        repourl: ${{ vars.PROD_REPO_URL }}
      run: |
        sed -i "s#REPO_URL#${repourl}#g" helm/chart/values.yaml    

    - name: Deploy to EKS       
      run: |
        # VERSION=$(echo ${{ steps.update-version.outputs.new_version }})
        # UPDATE=$(echo ${{ steps.determine-update.outputs.update }})

        IMAGE_TAG=$(cat VERSION)
        echo "new tag is : $IMAGE_TAG"
        helm upgrade --install nodeapp-prod helm/chart -f helm/chart/values-prod.yaml -n prod --create-namespace --set image.tag=$IMAGE_TAG

